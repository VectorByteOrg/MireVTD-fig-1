{
  "hash": "689f490f8a803453fe9eaf2989a94cb7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Reproducing Fig. 1 — MireVTD paper\"\nsubtitle: \"Thermal Performance Curve Fitting Using VectorByte Dataset 578\"\nauthor: \"Paul Huxley\"\ndate: \"2025-12-08\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-summary: \"Show code\"\nexecute:\n  freeze: auto\n  warning: false\n  message: false\n---\n\n\n## Overview\n\nThis page downloads VectorByte dataset **578**, wrangles development-rate data, fits Bayesian thermal performance curve (TPC) models using **bayesTPC**/**nimble**, and reproduces the multi-panel figure used as Fig. 1.\n\n**Important:** The MCMC is computationally heavy. For public repos / GitHub Pages, the recommended workflow is:\n\n1.  Run locally once with `run_mcmc <- TRUE` (creates `results/drate_output_models.rds`)\n2.  Commit the `results/` outputs\n3.  Keep `run_mcmc <- FALSE` for fast website renders\n\n------------------------------------------------------------------------\n## 1. Load libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(tidyverse)\nlibrary(nimble)\nlibrary(bayesTPC)\nlibrary(coda)\nlibrary(HDInterval)\nlibrary(parallel)\nlibrary(doParallel)\nlibrary(patchwork)\nlibrary(cowplot)\nlibrary(EnvStats)\n```\n:::\n\n\n## 2. Controls for public rendering\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set TRUE only when running locally to generate the cached model outputs\nrun_mcmc <- FALSE\nrds_file <- \"results/drate_output_models.rds\"\n\ndir.create(\"results\", showWarnings = FALSE)\n```\n:::\n\n\n\n## 3. Minimal VectorByte dataset retrieval function\n\nThis replaces the full interactive API client. It downloads the dataset cleanly and returns a dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_vectorbyte_dataset <- function(id, useQA = FALSE) {\n  base <- paste0(\"https://vectorbyte\", ifelse(useQA, \"-qa\", \"\"), \".crc.nd.edu\")\n  url  <- paste0(base, \"/portal/api/vectraits-dataset/\", id, \"/?format=json\")\n  raw  <- GET(url)\n  stop_for_status(raw)\n  fromJSON(content(raw, \"text\"), flatten = TRUE)[[1]]\n}\n```\n:::\n\n\n## 4. Download and inspect dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- get_vectorbyte_dataset(578)\n\n# Optional check of structure\ndf %>% distinct(OriginalTraitName, Interactor1Temp, SecondStressorValue)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   OriginalTraitName Interactor1Temp SecondStressorValue\n1   development time              22                  55\n2   development time              32                  55\n3   development time              22                 110\n4   development time              26                 110\n5   development time              32                 110\n6   development time              34                 110\n7   development time              22                 165\n8   development time              26                 165\n9   development time              32                 165\n10  development time              34                 165\n11  development time              22                 220\n12  development time              26                 220\n13  development time              32                 220\n14  development time              34                 220\n15  development time              26                  55\n16  development time              34                  55\n```\n\n\n:::\n:::\n\n\n## 5. Data wrangling for development rate analysis\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mean curve\ndevelopment_rate_mean <- df %>% \n  filter(SecondStressorValue == 165) %>%\n  group_by(Interactor1Temp) %>%\n  summarise(Trait = mean(1 / OriginalTraitValue), .groups = \"drop\") %>%\n  mutate(curve_ID = factor(1), Temp = Interactor1Temp)\n\n# Individual observations\ndevelopment_rate_individuals <- df %>%\n  filter(SecondStressorValue == 165) %>%\n  mutate(curve_ID = factor(2),\n         Temp = Interactor1Temp,\n         Trait = 1 / OriginalTraitValue)\n\n# Combined dataset\ndrate_dat <- bind_rows(development_rate_mean, development_rate_individuals)\n```\n:::\n\n\n## 6. Plot raw data\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_raw <- ggplot() +\n  geom_jitter(data = development_rate_individuals,\n              aes(Temp, Trait),\n              size = 2, shape = 21, fill = \"black\", col = \"white\",\n              width = 0.12) +\n  geom_point(data = development_rate_mean,\n             aes(Temp, Trait),\n             size = 3, shape = 22, colour = \"black\", fill = \"red\") +\n  theme_bw()\n\np_raw\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## 7. Hyperparameters for Bayesian TPC fitting\n\n### Thermal performance curve model choice\n\nThe exponential model used to describe temperature-dependent development time\n(Equation 2 in the main text) is not unimodal and does not have defined values for\n$T_\\mathrm{min}$, $T_\\mathrm{pk}$, $B_\\mathrm{pk}$, or $T_\\mathrm{max}$.\nTo facilitate direct comparison with previous studies, we therefore fitted the\nstandard **Brière thermal performance curve model** to *inverted development times*\n(i.e. development rate, $1/\\alpha$).\n\nThe Brière model was fitted as implemented in the `bayesTPC` package in **R** (Brière et al. 1999; Sorek et al. 2025).\n\n$$\n\\label{eq:BriereModel}\n\\frac{1}{\\alpha(T)} =\nq \\cdot T \\cdot (T - T_\\mathrm{min}) \\cdot\n\\sqrt{(T_\\mathrm{max} - T)} \\cdot\n\\mathbb{I}(T > T_\\mathrm{min}) \\cdot \\mathbb{I}(T < T_\\mathrm{max})\n$$\n\nHere, $T$ is temperature (°C),\n$T_\\mathrm{min}$ is the lower thermal limit at which rates become zero,\n$T_\\mathrm{max}$ is the upper thermal limit at which rates become zero,\nand $q$ is a scaling parameter that determines the maximum rate.\n\nPeak temperature ($T_\\mathrm{pk}$) and peak performance ($B_\\mathrm{pk}$) were not\nexplicit parameters of the model and were therefore estimated numerically from\nposterior samples of each fitted thermal performance curve. These quantities were\nsummarized using posterior medians and Highest Posterior Density (HPD) intervals.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niterations <- 50000\nburnin     <- 10000\ntemps      <- seq(0, 50, length = 1000)\n```\n:::\n\n\n\n#### 8. Prepare data and fit TPC models (averages vs individuals)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_list <- split(drate_dat, drate_dat$curve_ID)\n\nif (run_mcmc) {\n\n  # Parallel backend (adjust cores according to your system)\n  cl <- makeCluster(min(10, detectCores()))\n  registerDoParallel(cl)\n\n  drate_output_models <- foreach(i = seq_along(data_list)) %dopar% {\n\n    dat <- data_list[[i]]\n    lf.data.bTPC <- list(Temp = dat$Temp, Trait = dat$Trait)\n\n    library(nimble)\n    library(bayesTPC)\n\n    b_TPC(data     = lf.data.bTPC,\n          model    = \"briere\",\n          priors   = list(T_min = \"dunif(10,20)\",\n                          T_max = \"dunif(30,40)\"),\n          inits    = list(T_min = 15, T_max = 35),\n          thin     = 5,\n          samplerType = \"AF_slice\",\n          burn     = burnin,\n          niter    = iterations)\n  }\n\n  stopCluster(cl)\n\n  saveRDS(drate_output_models, rds_file)\n\n} else {\n\n  if (!file.exists(rds_file)) {\n    stop(\n      \"Missing cached models at: \", rds_file, \"\\n\",\n      \"Run locally once with run_mcmc <- TRUE to create it, then commit results/.\"\n    )\n  }\n\n  drate_output_models <- readRDS(rds_file)\n}\n```\n:::\n\n\n## 9. Posterior summaries, predictions, and HPDs\n\n\n::: {.cell}\n\n```{.r .cell-code}\npars      <- list()\nfits      <- list()\ndrateHPD  <- list()\n\nfor (i in seq_along(drate_output_models)) {\n\n  m  <- drate_output_models[[i]]\n  samples <- m$samples\n  hpds    <- HPDinterval(samples)\n\n  # Prediction grid\n  mybriere <- get_model_function(\"briere\")\n  l <- nrow(samples)\n\n  pred_mat <- matrix(NA, nrow = l, ncol = length(temps))\n\n  for (k in 1:l) {\n    pred_mat[k, ] <- mybriere(temps,\n                              T_max = samples[k, 1],\n                              T_min = samples[k, 2],\n                              q     = samples[k, 3])\n  }\n\n  # HPD intervals across temperatures\n  HPDtemp <- sapply(seq_along(temps), function(j) {\n    interval <- HPDinterval(mcmc(pred_mat[, j]))\n    c(lower = interval[1], upper = interval[2])\n  })\n\n  drateHPD[[i]] <- as.data.frame(t(HPDtemp)) |>\n    mutate(Temp = temps,\n           curve_ID = factor(i),\n           Trait_lwr = lower,\n           Trait_upr = upper) |>\n    select(Temp, Trait_lwr, Trait_upr, curve_ID)\n\n  # Fit summaries\n  fit_sum <- predict(m, temp_interval = temps)\n  fit_sum$temp_interval <- NULL\n\n  fits[[i]] <- bind_cols(Temp = temps, fit_sum,\n                         curve_ID = factor(i),\n                         species  = \"Aedes aegypti\")\n\n  # Peak estimates\n  Tmax_vals <- samples[,1]\n  Tmin_vals <- samples[,2]\n\n  Tpk_samples <- temps[apply(pred_mat, 1, which.max)]\n  Bpk_samples <- apply(pred_mat, 1, max)\n\n  pars[[i]] <- tibble(\n    curve_ID = factor(i),\n    Tmin_mean = mean(Tmin_vals),\n    Tmin_lwr  = hpds[2,1],\n    Tmin_upr  = hpds[2,2],\n    Tmax_mean = mean(Tmax_vals),\n    Tmax_lwr  = hpds[1,1],\n    Tmax_upr  = hpds[1,2],\n    Tpk_median = median(Tpk_samples),\n    Tpk_lwr    = HPDinterval(as.mcmc(Tpk_samples))[1],\n    Tpk_upr    = HPDinterval(as.mcmc(Tpk_samples))[2],\n    Bpk_median = median(Bpk_samples),\n    Bpk_lwr    = HPDinterval(as.mcmc(Bpk_samples))[1],\n    Bpk_upr    = HPDinterval(as.mcmc(Bpk_samples))[2]\n  )\n}\n\ndrateHPD_combined <- bind_rows(drateHPD)\nfits_combined     <- bind_rows(fits)\npars_combined     <- bind_rows(pars)\n```\n:::\n\n\n## 10. Plotting: TPC Fits + Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nj1 <-\n  ggplot() +\n  scale_y_continuous(expression(plain(paste(\"development rate,\",\" day\"^{-1}))),\n                     limits =c(-.01,.41),\n                     expand = c(0, 0),\n                     breaks=seq(0,.4, by=.1)) +\n  scale_x_continuous(expression(plain(paste(\" Temperature, \", degree, \"C\")))) +\n\n  # Plot HPD intervals using geom_ribbon\n  geom_ribbon(aes(Temp, ymin = Trait_lwr, ymax = Trait_upr, group = curve_ID, fill = curve_ID),\n              data = drateHPD_combined, alpha = 0.5, inherit.aes = FALSE) +\n\n  # Plot the fit lines\n  geom_line(aes(Temp, medians, group = curve_ID, colour = curve_ID),\n            data = fits_combined, linewidth = 0.2) +\n\n  # Plot points for curve_ID 1\n  geom_point(data = subset(drate_dat, curve_ID == 1),\n             aes(Temp, Trait, col = curve_ID, fill = curve_ID, shape = curve_ID),\n             stroke = .2, size = 3) +\n\n  # Plot points for curve_ID 2 with jitter\n  geom_jitter(data = subset(drate_dat, curve_ID == 2),\n              aes(Temp, Trait, col = curve_ID, fill = curve_ID, shape = curve_ID),\n              alpha = .3, width = .5, stroke = .2, size = 1) +\n\n  # Customize legend and other aesthetics\n  scale_shape_manual(name = expression(bold(\"\")),\n                     labels = c(\"averages\", \"individuals\"),\n                     values = c(24, 23),\n                     guide = guide_legend(nrow = 2, ncol = 1,\n                                          direction = \"horizontal\",\n                                          title.position = \"top\",\n                                          title.hjust = 0.5)) +\n\n  scale_fill_manual(name = expression(bold(\"\")),\n                    labels = c(\"averages\", \"individuals\"),\n                    values = c(\"#bdd7e7\", \"#fb8501\"),\n                    guide = guide_legend(nrow = 2, ncol = 1,\n                                         direction = \"horizontal\",\n                                         title.position = \"top\",\n                                         title.hjust = 0.5)) +\n\n  scale_colour_manual(name = expression(bold(\"\")),\n                      labels = c(\"averages\", \"individuals\"),\n                      values = c(\"#000000\", \"#fb8501\"),\n                      guide = guide_legend(nrow = 2, ncol = 1,\n                                           direction = \"horizontal\",\n                                           title.position = \"top\",\n                                           title.hjust = 0.5)) +\n\n  theme_bw(base_size = 14) +\n  theme(legend.position = c(.255, .9),\n        text = element_text(face = 'plain'),\n        legend.background = element_rect(colour = \"black\", linewidth = 0.15),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_text(size = 1),\n        legend.key.spacing.y = unit(.1, \"cm\"),\n        legend.text = element_text(size = 6.5),\n        legend.box.margin = margin(0, 0, 0, 0),\n        legend.key.height = unit(.1, \"cm\"),\n        legend.spacing = unit(1, \"mm\"),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank()) +\n\n  # Annotate plot\n  annotate(\"text\", x = 48, y = 0.35, label = 'a', size = 4.5)\n\nj1\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n## 11. Panel b: Tpk vs Bpk (j2)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nj2 <- pars_combined %>% mutate(curve_ID = factor(curve_ID)) %>%\n  ggplot()+\n  geom_linerange(aes(x=Tpk_median,xmin=Tpk_lwr,xmax=Tpk_upr,y=Bpk_median,\n                     group=curve_ID, col=curve_ID),lwd=.35)+\n  geom_linerange(aes(y=Bpk_median,ymin=Bpk_lwr,ymax=Bpk_upr,x=Tpk_median,\n                     group=curve_ID, col=curve_ID), lwd=.35)+\n  geom_point(aes(Tpk_median,Bpk_median,group=curve_ID,shape=curve_ID,fill=curve_ID), col=\"black\",\n             alpha = 1, stroke=0.25, size=1.5) +\n  scale_x_continuous(name=expression(plain(paste(italic(T)[pk]))),\n                     limits =c(25.75,34.25),\n                     expand = c(0, 0),\n                     breaks=seq(26,34, by=4))+\n  scale_y_continuous(name=expression(plain(\"rate\")),\n                     limits =c(-0.01,.41),\n                     expand = c(0, 0),\n                     breaks=seq(0,.4, by=0.2))+\n  theme_bw(base_size = 14)+\n  scale_shape_manual(name=expression(bold(\"\")),\n                     labels = c(\"averages\", \"individuals\"),\n                     values = c(24,23),\n                     guide = guide_legend(nrow=2,ncol=1,\n                                          direction = \"horizontal\",\n                                          title.position = \"top\",\n                                          title.hjust=0.5))+\n  scale_fill_manual(name=expression(bold(\"\")),\n                    labels = c(\"averages\", \"individuals\"),\n                    values = c(\"#bdd7e7\",\"#fb8501\"),\n                    guide = guide_legend(nrow=2,ncol=1,\n                                         direction = \"horizontal\",\n                                         title.position = \"top\",\n                                         title.hjust=0.5))+\n  scale_colour_manual(name=expression(bold(\"\")),\n                      labels = c(\"averages\", \"individuals\"),\n                      values = c(\"#bdd7e7\",\"#fb8501\"),\n                      guide = guide_legend(nrow=2,ncol=1,\n                                           direction = \"horizontal\",\n                                           title.position = \"top\",\n                                           title.hjust=0.5))+\n  theme(legend.position = \"none\",\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank())+\n  annotate(\"text\", x = 33, y = 0.35, label = 'b', size = 4.5)\n\nj2\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n## 12. Panel c: Tmax vs Tmin\n\n\n::: {.cell}\n\n```{.r .cell-code}\nj3 <-\n  pars_combined %>% mutate(curve_ID = factor(curve_ID)) %>%\n  ggplot()+\n  geom_linerange(aes(y=Tmax_mean,ymin=Tmax_lwr,ymax=Tmax_upr,x=Tmin_mean,group=curve_ID, col=curve_ID),lwd=.35)+\n  geom_linerange(aes(x=Tmin_mean,xmin=Tmin_lwr,xmax=Tmin_upr,y=Tmax_mean,group=curve_ID, col=curve_ID),lwd=.35)+\n  geom_point(aes(Tmin_mean,Tmax_mean,group=curve_ID,shape=curve_ID,fill=curve_ID), col=\"black\",\n             alpha = 1, stroke=0.25, size=1.5)+\n  scale_y_continuous(name=expression(plain(paste(italic(T)[max]))),\n                     limits =c(29,41),\n                     expand = c(0, 0),\n                     breaks=seq(30,40, by=5))+\n  scale_x_continuous(name=expression(plain(paste(italic(T)[min]))),\n                     limits =c(9.9,20.1),\n                     expand = c(0, 0),\n                     breaks=seq(10,20, by=5))+\n  theme_bw(base_size = 14)+\n  scale_shape_manual(name=expression(bold(\"\")),\n                     labels = c(\"averages\", \"individuals\"),\n                     values = c(24,23),\n                     guide = guide_legend(nrow=2,ncol=1,\n                                          direction = \"horizontal\",\n                                          title.position = \"top\",\n                                          title.hjust=0.5))+\n  scale_fill_manual(name=expression(bold(\"\")),\n                    labels = c(\"averages\", \"individuals\"),\n                    values = c(\"#bdd7e7\",\"#fb8501\"),\n                    guide = guide_legend(nrow=2,ncol=1,\n                                         direction = \"horizontal\",\n                                         title.position = \"top\",\n                                         title.hjust=0.5))+\n  scale_colour_manual(name=expression(bold(\"\")),\n                      labels = c(\"averages\", \"individuals\"),\n                      values = c(\"#bdd7e7\",\"#fb8501\"),\n                      guide = guide_legend(nrow=2,ncol=1,\n                                           direction = \"horizontal\",\n                                           title.position = \"top\",\n                                           title.hjust=0.5))+\n  theme(legend.position = \"none\",\n        legend.title = element_text(size=1),\n        legend.text = element_text(size=6),\n        legend.key.height = unit(.2, \"cm\"),\n        legend.key.spacing.y = unit(.01, \"cm\"),\n        legend.key.width = unit(.3, \"cm\"),\n        legend.spacing = unit(.01, \"cm\"),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank())+\n  annotate(\"text\", x = 18.5, y = 38.85, label = 'c', size = 4.5)\n\nj3\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n## 12. Save panels\n\n\n::: {.cell}\n\n```{.r .cell-code}\nj4 <- j2 + j3 + plot_layout(ncol = 1)\nj5 <- j1 + j4 + plot_layout(ncol = 2)\n\nggsave(\"results/example-of-averages-vs-individuals.pdf\", j4,\n       width = 6.5, height = 6.5, units = \"cm\")\n\nggsave(\"results/panel-example-ave-vs-inds.pdf\", j5,\n       width = 16, height = 7.75, units = \"cm\")\n\nj5\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n############################################################################### \n\n# END OF SCRIPT\n\n############################################################################### \n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}